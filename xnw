--!optimize 2

-- Who's AP? w6lv (UI By X) - INTEGRATED VERSION
-- Old auto-parry logic + Old clash system + New features

local function VectorMagnitude(v)
    return math.sqrt(v.X * v.X + v.Y * v.Y + v.Z * v.Z)
end

local lastBallVelocityCheck = 0
local cachedBallVelocity = vector.create(0, 0, 0)
local velocityCacheTime = 0.016

_G.GetBallVelocity = function(ball)
    if not ball then 
        cachedBallVelocity = vector.create(0, 0, 0)
        return cachedBallVelocity
    end
    local currentTime = tick()
    if currentTime - lastBallVelocityCheck < velocityCacheTime then
        return cachedBallVelocity
    end
    local success, velocity = pcall(function() return ball.Velocity end)
    if success and velocity then
        cachedBallVelocity = velocity
    else
        cachedBallVelocity = vector.create(0, 0, 0)
    end
    lastBallVelocityCheck = currentTime
    return cachedBallVelocity
end

local MAX = math.max
local MIN = math.min

local Keybinds = {
    ToggleAutoParry = nil,
    ToggleAutoclicker = nil,
}

-- AUTOCLICKER SETTINGS
local AutoclickerSettings = {
    Mode = "hold",
    ClickInterval = 0.016,
}

local Config = {
    AutoParryEnabled = false,
    DirectionCheckEnabled = true,
    IgnoreDirectionAtCloseRange = true,
    CloseRangeDistance = 35,
    
    -- OLD AUTO-PARRY TIMING (from old script)
    ParryCooldown = 0.15,
    BaseParryTime = 0.5,  -- Base parry time for normal speeds
    ParryBufferDistance = 8,
    MinParrySpeed = 10,
    
    -- OLD DYNAMIC PARRY TIMING (parry earlier at higher speeds)
    DynamicParryTiming = true,
    ParryTimeMin = 0.15,  -- Minimum parry time (for very fast balls)
    ParryTimeMax = 0.5,   -- Maximum parry time (for slow balls)
    SpeedForMinTiming = 400,  -- Speed at which we use minimum timing
    SpeedForMaxTiming = 100,  -- Speed at which we use maximum timing
    
    -- OLD DIRECTION CHECKING
    MinDirectionDotProduct = 0.3,
    IgnoreDirectionUnderDistance = 20,
    
    -- OLD EMERGENCY MODE
    EmergencyDistance = 12,
    EmergencyParryCooldown = 0.08,
    
    PingCompensation = 0.5,
    ParryAggressiveness = 1.0,
    
    UseDistanceSpeedCorrelation = true,
    DistanceSpeedRanges = {
        {0, 15, 0.85, 0.00006},
        {15, 30, 0.90, 0.00008},
        {30, 50, 0.94, 0.00010},
        {50, 70, 0.98, 0.00012},
        {70, 90, 1.03, 0.00014},
        {90, 999, 1.08, 0.00016},
    },
    
    ProgressiveDistanceEnabled = true,
    ProgressiveDistanceRanges = {
        {10, 3.5},
        {20, 2.8},
        {35, 2.3},
        {50, 1.7},
        {70, 1.25},
        {999, 1.0},
    },
    
    DynamicClickRates = true,
    ClickRateZones = {
        {10, 6, 2},
        {18, 5, 3},
        {28, 4, 6},
        {40, 3, 12},
        {60, 2, 20},
        {999, 1, 35},
    },
    
    SpeedBasedRapidParry = true,
    SpeedRapidParryTiers = {
        {450, 70},
        {650, 90},
        {850, 110},
        {1050, 140},
        {1250, 170},
    },
    
    AutoPopAbilities = {
        DefensivePopTiming = 0.3,
        OffensivePopDelay = 0.0,
        
        Infinity = { enabled = true },
        RagingDeflection = { enabled = true },
        CalmingDeflection = { enabled = true },
        Singularity = { enabled = true, useOnParry = true },
        AerodynamicSlash = { enabled = true, useOnParry = true },
        Rapture = { enabled = true, useOnParry = true },
        DeathSlash = { 
            enabled = true, 
            useOnParry = true,
            qteEnabled = true,
            qteDelay = 2.7,
            qtePressCount = 1,
        },
        SlashOfFury = {
            enabled = true,
            useOnParry = true,
            clickCount = 38,
            clickDelay = 0.1,
            prepareForReturn = true,
            activateMaxDistance = 100,
            activateMinDistance = 40,
            activateMinSpeed = 150,
        },
    },
    
    AeroDefenseEnabled = true,
    AeroDefense = {
        useVFXDetection = true,
        useDynamicDelay = true,
        baseParryDelay = 0.30,
        delayPerDistance = 0.0015,
        minDelay = 0.22,
        maxDelay = 0.70,
        minSpeedForParry = 150,
        alignmentThreshold = 0.75,
    },
    
    MartyrdomDetectionEnabled = true,
    MartyrdomSafeDistance = 50,
    MartyrdomExplosionDelay = 0.3,
    MartyrdomPreventDistance = 60,
    MartyrdomHealthThreshold = 30,

    FreezeDetectionEnabled = true,
    FreezeBallSpeedThreshold = 10,
    FreezeMinDuration = 0.1,
    FreezeParryEnabled = true,

    TelekinesisDetectionEnabled = true,
    TelekinesisVelocityThreshold = 400,
    TelekinesisParryDelay = 0.12,
    
    CurveDetectionEnabled = false,
    ShowCurveIndicator = false,
    
    -- OLD CLASH SYSTEM (REDESIGNED - from old script)
    AutoClashEnabled = true,
    ClashActivationTime = 0.8,  -- If 3+ parries within 0.8 seconds
    ClashMinParries = 3,  -- Need at least 3 parries to trigger
    ClashDeactivationTime = 3.0,  -- Stay active for 3 seconds after LAST PARRY
    ClashMinSpeed = 60,  -- Minimum speed to count parry
    ClashExtendOnParry = true,  -- Extend clash mode on each parry
    ClashSpamDelay = 0,  -- No delay between spam clicks
    
    PanicParryEnabled = true,
    PanicParryDistance = 20,
}

local TBSettings = {
    Enabled = false,
    ClickDelay = 60,
    LastClickTime = 0,
    HasClicked = false,
    Keybind = nil,
}

local ESPSettings = {
    Enabled = true,
    AbilityColor = Color3.fromRGB(255, 255, 255),
    Opacity = 1,
    TextSize = 14,
    ShowDistance = true,
    DistanceColor = Color3.fromRGB(0, 255, 255),
}

_G.AutoParryState = {
    LocalPlayer = game:GetService("Players").LocalPlayer,
    Clicked = false,
    AutoclickerMode = false,
    CachedCharacter = nil,
    CachedHRP = nil,
    CachedPlayerModel = nil,
    CachedBallsFolder = nil,
    CachedAliveFolder = nil,
    ThreadRunning = true,
    CompensatedParryTime = 0.47,
    LastPingUpdate = 0,
    BallData = {
        isTargeted = false,
        lastSpeed = 0,
        speedHistory = {},
        highestRecentSpeed = 0,
        lastHighSpeedTime = 0,
        lastDistance = 999,
        lastBallPosition = nil,
        approachVelocity = 0,
        wasTargetedLastFrame = false,
        ballExists = false,
        ballRespawnTime = 0,
    },
    BallTracking = {
        lastBallSpeed = 0,
        lastCheckTime = 0,
        lastBallDistance = 999,
        peakSpeed = 0,
        peakSpeedTime = 0,
        speedSmoothWindow = 0.1,
        
        lastTargetedPlayer = nil,
        lastTargetedPlayerAbility = nil,
        speedBeforeSpike = 0,
        spikeDetected = false,
        spikeTime = 0,
    },
    
    LastParryTime = 0,
    ClashMode = false,
    ClashModeActivatedAt = 0,
    LastClashParryTime = 0,
    ParryHistory = {},  -- Track all recent parries with timestamps
    DeathTracking = {
        wasAlive = true,
        lastDeathSpeed = 0,
        lastDeathDistance = 0,
        lastDeathMultiplier = 0,
    },
    DynamicClick = {
        lastClickTime = 0,
        clickCount = 0,
    },
    AbilityTracking = {
        InfinityActive = false,
        InfinityPauseUntil = 0,
        InfinityCooldownUntil = 0,
        SingularityEquipped = false,
        SingularityCooldownUntil = 0,
        SingularityDuration = 10,
        SingularityCooldown = 18,
        LastAbilityPress = 0,
        SingularityCapeWasActive = false,
        
        EnemyUsedSingularity = false,
        EnemyUsedInfinity = false,
        DangerousAbilityDetectedTime = 0,
        
        LastAutoPop = 0,
        LastDefensivePop = 0,
        CurrentAbility = "",
        LastAbilityCheck = 0,
        
        SoFActive = false,
        SoFStartTime = 0,
        SoFPreparedForReturn = false,
        
        AeroVFXDetected = false,
        AeroVFXDetectionTime = 0,
        AeroTornadoStartTime = 0,
        AeroUserPosition = nil,
        AeroCalculatedDelay = 0.88,
        
        ActiveMartyrdoms = {},
        LastPlayerStates = {},
        PlayersWithMartyrdom = {},
        LowHealthPlayers = {},
        DangerZones = {},
        
        BallFrozen = false,
        FreezeStartTime = 0,
        FreezeDetectedTime = 0,
        FreezeJustExpired = false,
        FreezeExpireTime = 0,
        LastBallSpeed = 0,
        
        TelekinesisActive = false,
        TelekinesisDetectedTime = 0,
        TelekinesisTargetChanged = false,
        PreTelekinesisTarget = nil,
        
        TelekinesisRetargetTime = 0,
        TelekinesisLastTarget = nil,
        LastTargetCheck = 0,
        
        AbilityCooldowns = {
            Infinity = 0,
            RagingDeflection = 0,
            CalmingDeflection = 0,
            Singularity = 0,
            AerodynamicSlash = 0,
            Rapture = 0,
            DeathSlash = 0,
            SlashOfFury = 0,
        },
    }
}

if not _ESPAbilityCache then
    _ESPAbilityCache = {}
end

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

-- PING COMPENSATION
task.spawn(function()
    while task.wait(1.0) do
        pcall(function()
            local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue()
            if ping and ping > 0 then
                local compensation = (ping / 1000) * Config.PingCompensation
                _G.AutoParryState.CompensatedParryTime = MAX(0.15, MIN(0.65, Config.BaseParryTime + compensation))
            end
        end)
    end
end)

-- HELPER FUNCTIONS
local function GetCurrentBall()
    if _G.AutoParryState.CachedBallsFolder then
        local children = _G.AutoParryState.CachedBallsFolder:GetChildren()
        return children and children[1]
    end
    return nil
end

local function GetPlayerPosition()
    if _G.AutoParryState.CachedHRP then
        return _G.AutoParryState.CachedHRP.Position
    end
    return nil
end

local isTargetedCache = {
    value = false,
    lastCheck = 0,
    checkInterval = 0.016
}

local function IsTargeted()
    local currentTime = tick()
    if currentTime - isTargetedCache.lastCheck < isTargetedCache.checkInterval then
        return isTargetedCache.value
    end
    local targeted = _G.AutoParryState.CachedPlayerModel and _G.AutoParryState.CachedPlayerModel:FindFirstChild("Highlight") ~= nil
    isTargetedCache.value = targeted
    isTargetedCache.lastCheck = currentTime
    return targeted
end

local function IsTargetedDirect()
    local aliveFolder = workspace:FindFirstChild("Alive")
    if not aliveFolder then return false end
    
    local playerModel = aliveFolder:FindFirstChild(_G.AutoParryState.LocalPlayer.Name)
    if not playerModel then return false end
    
    return playerModel:FindFirstChild("Highlight") ~= nil
end

local function IsBallComingTowardsPlayer(ballPos, ballVel, playerPos)
    local toPlayer = playerPos - ballPos
    local toPlayerMag = VectorMagnitude(toPlayer)

    if toPlayerMag < 0.01 then
        return true
    end

    local toPlayerNorm = toPlayer / toPlayerMag
    local ballSpeed = VectorMagnitude(ballVel)

    if ballSpeed < 1 then
        return true
    end

    local ballDirNorm = ballVel / ballSpeed
    local dotProduct = toPlayerNorm.X * ballDirNorm.X + toPlayerNorm.Y * ballDirNorm.Y + toPlayerNorm.Z * ballDirNorm.Z

    local distance = toPlayerMag
    local threshold

    if distance < 25 then
        threshold = -0.5
    elseif distance < 50 then
        threshold = -0.2
    elseif distance < 75 then
        threshold = 0.1
    else
        threshold = 0.2
    end

    return dotProduct > threshold
end

local CurveState = {
    ballPositionHistory = {},
    lastCurveLevel = "None",
    lastCurveMultiplier = 1.0,
    curveIntensity = 0,
    curveDirection = vector.create(0, 0, 0),
    lastDisplayLevel = "None",
    lastDisplayIntensity = 0,
    lastBallExists = false,
}

local CurveMultipliers = {
    None = 1.0,
    Light = 1.01,
    Medium = 1.03,
    Heavy = 1.05,
    Extreme = 1.08,
}

local CurveColors = {
    None = Color3.fromRGB(255, 255, 255),
    Light = Color3.fromRGB(255, 255, 0),
    Medium = Color3.fromRGB(255, 165, 0),
    Heavy = Color3.fromRGB(255, 69, 0),
    Extreme = Color3.fromRGB(255, 0, 0),
}

local function VectorNormalize(v)
    local mag = VectorMagnitude(v)
    if mag < 0.001 then return vector.create(0, 0, 0) end
    return vector.create(v.X / mag, v.Y / mag, v.Z / mag)
end

local function VectorDot(v1, v2)
    return v1.X * v2.X + v1.Y * v2.Y + v1.Z * v2.Z
end

local function VectorCross(v1, v2)
    return vector.create(
        v1.Y * v2.Z - v1.Z * v2.Y,
        v1.Z * v2.X - v1.X * v2.Z,
        v1.X * v2.Y - v1.Y * v2.X
    )
end

local function CalculateCurveIntensity(ballPos, ballVel, playerPos)
    if not Config.CurveDetectionEnabled then
        return 0, "None"
    end
    
    local ballSpeed = VectorMagnitude(ballVel)
    if ballSpeed < 60 then
        return 0, "None"
    end
    
    local toBall = ballPos - playerPos
    local distanceToPlayer = VectorMagnitude(toBall)
    
    if distanceToPlayer < 5 then
        return 0, "None"
    end
    
    local toBallNorm = VectorNormalize(toBall)
    local ballVelNorm = VectorNormalize(ballVel)
    local alignment = VectorDot(toBallNorm, ballVelNorm)
    
    if alignment > 0 then
        return 0, "None"
    end
    
    local perpendicular = math.sqrt(math.max(0, 1 - alignment * alignment))
    
    local trajectoryDeviation = 0
    if #CurveState.ballPositionHistory >= 3 then
        local recent = CurveState.ballPositionHistory
        local pos1 = recent[#recent]
        local pos2 = recent[#recent - 1]
        local pos3 = recent[#recent - 2]
        
        local expectedMove = vector.create(pos2.X - pos3.X, pos2.Y - pos3.Y, pos2.Z - pos3.Z)
        local actualMove = vector.create(pos1.X - pos2.X, pos1.Y - pos2.Y, pos1.Z - pos2.Z)
        
        local expectedNorm = VectorNormalize(expectedMove)
        local actualNorm = VectorNormalize(actualMove)
        
        if VectorMagnitude(expectedMove) > 1 and VectorMagnitude(actualMove) > 1 then
            trajectoryDeviation = math.max(0, 1 - VectorDot(expectedNorm, actualNorm))
        end
    end
    
    local combinedCurve = (perpendicular * 0.6) + (trajectoryDeviation * 0.4)
    
    CurveState.curveIntensity = combinedCurve
    
    local curveLevel = "None"
    if combinedCurve > 0.35 then
        curveLevel = "Extreme"
    elseif combinedCurve > 0.25 then
        curveLevel = "Heavy"
    elseif combinedCurve > 0.18 then
        curveLevel = "Medium"
    elseif combinedCurve > 0.12 then
        curveLevel = "Light"
    end
    
    if VectorMagnitude(ballVel) > 1 then
        local crossProd = VectorCross(ballVelNorm, toBallNorm)
        CurveState.curveDirection = VectorNormalize(crossProd)
    end
    
    return combinedCurve, curveLevel
end

local function UpdateCurveTracking(ballPos, ballVel)
    table.insert(CurveState.ballPositionHistory, ballPos)
    
    while #CurveState.ballPositionHistory > 3 do
        table.remove(CurveState.ballPositionHistory, 1)
    end
end

local function GetCurveTimingMultiplier(ballPos, ballVel, playerPos)
    local curveIntensity, curveLevel = CalculateCurveIntensity(ballPos, ballVel, playerPos)
    CurveState.lastCurveLevel = curveLevel
    CurveState.lastCurveMultiplier = CurveMultipliers[curveLevel]
    return CurveState.lastCurveMultiplier
end

local function ProcessCurveDetection(ball, playerPos)
    if not ball or not playerPos then
        CurveState.ballPositionHistory = {}
        CurveState.lastCurveLevel = "None"
        CurveState.lastCurveMultiplier = 1.0
        CurveState.curveIntensity = 0
        CurveState.lastDisplayLevel = "None"
        CurveState.lastDisplayIntensity = 0
        CurveState.lastBallExists = false
        return 1.0
    end
    
    CurveState.lastBallExists = true
    
    local ballPos = ball.Position
    local ballVel = _G.GetBallVelocity(ball)
    local ballSpeed = VectorMagnitude(ballVel)
    
    if ballSpeed < 60 then
        CurveState.ballPositionHistory = {}
        CurveState.lastCurveLevel = "None"
        CurveState.lastCurveMultiplier = 1.0
        CurveState.curveIntensity = 0
        CurveState.lastDisplayLevel = "None"
        CurveState.lastDisplayIntensity = 0
        return 1.0
    end
    
    UpdateCurveTracking(ballPos, ballVel)
    local multiplier = GetCurveTimingMultiplier(ballPos, ballVel, playerPos)
    
    CurveState.lastDisplayLevel = CurveState.lastCurveLevel
    CurveState.lastDisplayIntensity = CurveState.curveIntensity
    
    return multiplier
end

local function GetDynamicCurveMultiplier(ballPos, ballVel, playerPos, currentSpeed)
    return ProcessCurveDetection(GetCurrentBall(), playerPos)
end

local function ShouldCheckDirection(distance)
    if not Config.DirectionCheckEnabled then return false end
    if Config.IgnoreDirectionAtCloseRange and distance <= 60 then return false end
    return true
end

local function HasSingularityCape()
    local character = _G.AutoParryState.LocalPlayer.Character
    if character then
        local primaryPart = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
        if primaryPart and primaryPart:FindFirstChild("SingularityCape") then
            return true
        end
    end
    return false
end

local function GetCurrentBallTarget()
    local aliveFolder = workspace:FindFirstChild("Alive")
    if not aliveFolder then return nil, nil end
    
    for _, character in aliveFolder:GetChildren() do
        if character:FindFirstChild("Highlight") then
            local playerName = character.Name
            local player = Players:FindFirstChild(playerName)
            local ability = nil
            
            if player then
                ability = player:GetAttribute("EquippedAbility")
            end
            
            if not ability then
                ability = character:GetAttribute("EquippedAbility")
            end
            
            return playerName, ability and tostring(ability) or nil
        end
    end
    
    return nil, nil
end

local function FindAeroUserAndCalculateDelay()
    local aliveFolder = workspace:FindFirstChild("Alive")
    if not aliveFolder then return nil, 0.88 end
    
    local localName = _G.AutoParryState.LocalPlayer.Name
    local playerPos = GetPlayerPosition()
    if not playerPos then return nil, 0.88 end
    
    for _, character in aliveFolder:GetChildren() do
        if character.Name ~= localName then
            local player = Players:FindFirstChild(character.Name)
            if player then
                local ability = player:GetAttribute("EquippedAbility")
                if ability then
                    local abilityStr = tostring(ability):lower()
                    if abilityStr:find("aerodynamic") or abilityStr:find("aero") then
                        local enemyHRP = character:FindFirstChild("HumanoidRootPart")
                        if enemyHRP then
                            local enemyPos = enemyHRP.Position
                            local distance = VectorMagnitude(enemyPos - playerPos)
                            
                            local aeroConfig = Config.AeroDefense
                            if aeroConfig.useDynamicDelay then
                                local calculatedDelay = aeroConfig.baseParryDelay + (distance * aeroConfig.delayPerDistance)
                                calculatedDelay = MAX(aeroConfig.minDelay, MIN(aeroConfig.maxDelay, calculatedDelay))
                                return enemyPos, calculatedDelay
                            else
                                return enemyPos, aeroConfig.baseParryDelay
                            end
                        end
                    end
                end
            end
        end
    end
    
    return nil, Config.AeroDefense.baseParryDelay or 0.88
end

-- MARTYRDOM DETECTION FUNCTIONS
local function GetPlayerHealth(player)
    if not player or not player.Character then return 0 end
    local humanoid = player.Character:FindFirstChild("Humanoid")
    return humanoid and humanoid.Health or 0
end

local function HasMartyrdomAbility(player)
    if not player or not player.Character then return false end
    
    if player.Character:FindFirstChild("Martyrdom") then
        return true
    end
    
    local backpack = player:FindFirstChild("Backpack")
    if backpack and backpack:FindFirstChild("Martyrdom") then
        return true
    end
    
    local ability = player:GetAttribute("EquippedAbility")
    if ability then
        local abilityStr = tostring(ability):lower()
        if abilityStr:find("martyrdom") then
            return true
        end
    end
    
    return false
end

local function GetDistanceToPlayer(playerCharacter)
    if not playerCharacter then return math.huge end
    
    local myPos = GetPlayerPosition()
    if not myPos then return math.huge end
    
    local targetHRP = playerCharacter:FindFirstChild("HumanoidRootPart")
    if not targetHRP then return math.huge end
    
    return VectorMagnitude(targetHRP.Position - myPos)
end

local function TrackMartyrdomExplosion(playerName, deathPosition, deathTime)
    if not Config.MartyrdomDetectionEnabled then return end
    
    local explosionData = {
        position = deathPosition,
        time = deathTime,
        explodeTime = deathTime + Config.MartyrdomExplosionDelay,
        radius = Config.MartyrdomSafeDistance
    }
    
    local tracking = _G.AutoParryState.AbilityTracking
    tracking.ActiveMartyrdoms[playerName] = explosionData
    tracking.DangerZones[playerName] = explosionData
end

local function IsInMartyrdomDangerZone()
    if not Config.MartyrdomDetectionEnabled then return false end
    
    local myPos = GetPlayerPosition()
    if not myPos then return false end
    
    local tracking = _G.AutoParryState.AbilityTracking
    
    for playerName, zone in pairs(tracking.DangerZones) do
        local distance = VectorMagnitude(zone.position - myPos)
        
        if distance <= zone.radius then
            return true, playerName, distance
        end
    end
    
    return false
end

local function IsNearLowHealthMartyrdom()
    if not Config.MartyrdomDetectionEnabled then return false end
    
    local myPos = GetPlayerPosition()
    if not myPos then return false end
    
    local tracking = _G.AutoParryState.AbilityTracking
    
    for playerName, data in pairs(tracking.LowHealthPlayers) do
        if data.hasMartyrdom and data.health > 0 and data.health < Config.MartyrdomHealthThreshold then
            local distance = data.distance
            if distance <= Config.MartyrdomPreventDistance then
                return true, playerName, data.health, distance
            end
        end
    end
    
    return false
end

local function CheckMartyrdomDanger()
    if not Config.MartyrdomDetectionEnabled then return false, nil end
    
    local currentTime = tick()
    local myPos = GetPlayerPosition()
    
    if not myPos then return false, nil end
    
    local tracking = _G.AutoParryState.AbilityTracking
    
    local inZone, zoneName, zoneDistance = IsInMartyrdomDangerZone()
    if inZone then
        return true, { type = "zone", name = zoneName, distance = zoneDistance }
    end
    
    local nearLowHealth, playerName, health, distance = IsNearLowHealthMartyrdom()
    if nearLowHealth then
        return true, { type = "low_health", name = playerName, health = health, distance = distance }
    end
    
    for playerName, martyrdomData in pairs(tracking.ActiveMartyrdoms) do
        if currentTime >= martyrdomData.explodeTime - 0.1 then
            local distance = VectorMagnitude(martyrdomData.position - myPos)
            
            if distance <= Config.MartyrdomSafeDistance then
                return true, { type = "explosion", name = playerName, distance = distance }
            end
            
            if currentTime >= martyrdomData.explodeTime + 1.0 then
                tracking.ActiveMartyrdoms[playerName] = nil
                tracking.DangerZones[playerName] = nil
            end
        end
    end
    
    return false, nil
end

local function ShouldAvoidMartyrdom()
    local inDanger, dangerData = CheckMartyrdomDanger()
    return inDanger
end

-- FREEZE & TELEKINESIS DETECTION
local function DetectBallFreeze(currentSpeed, currentTime)
    if not Config.FreezeDetectionEnabled then return end

    local tracking = _G.AutoParryState.AbilityTracking

    if currentSpeed <= 2 and tracking.LastBallSpeed > 10 then
        tracking.BallFrozen = true
        tracking.FreezeStartTime = currentTime
        _G.AutoParryState.Clicked = false
    end

    if not tracking.BallFrozen and currentSpeed < 10 and tracking.LastBallSpeed > 50 then
        _G.AutoParryState.Clicked = false
    end

    if tracking.BallFrozen and currentSpeed > 50 then
        tracking.BallFrozen = false
        tracking.FreezeJustExpired = true
        tracking.FreezeExpireTime = currentTime
        _G.AutoParryState.Clicked = false
    end

    tracking.LastBallSpeed = currentSpeed
end

local function DetectTelekinesis(currentSpeed, currentTime)
    if not Config.TelekinesisDetectionEnabled then return end

    local tracking = _G.AutoParryState.AbilityTracking

    if tracking.BallFrozen and currentSpeed >= Config.TelekinesisVelocityThreshold then
        local currentTarget = IsTargeted()
        local targetChanged = currentTarget and currentTarget ~= tracking.TelekinesisLastTarget

        if targetChanged or (currentTime - tracking.LastTargetCheck) > 0.5 then
            tracking.TelekinesisActive = true
            tracking.TelekinesisRetargetTime = currentTime
            tracking.TelekinesisLastTarget = currentTarget
            tracking.BallFrozen = false
        end

        tracking.LastTargetCheck = currentTime
    end

    if tracking.TelekinesisActive and (currentTime - tracking.TelekinesisRetargetTime) > 1.0 then
        tracking.TelekinesisActive = false
    end
end

local function ShouldParryFrozenBall()
    if not Config.FreezeParryEnabled then return false end
    
    local tracking = _G.AutoParryState.AbilityTracking
    
    if tracking.BallFrozen and IsTargeted() then
        return true
    end
    
    return false
end

local function ShouldDelayForTelekinesis(currentTime)
    if not Config.TelekinesisDetectionEnabled then return false end
    
    local tracking = _G.AutoParryState.AbilityTracking
    
    if tracking.TelekinesisActive then
        local timeSinceRetarget = currentTime - tracking.TelekinesisRetargetTime

        if timeSinceRetarget < Config.TelekinesisRetargetDelay then
            return true
        end
    end
    
    return false
end

local function CheckFreezeAbility()
    if not Config.FreezeDetectionEnabled then return false end
    
    local Ball = GetCurrentBall()
    if not Ball then return false end
    
    local ballVel = _G.GetBallVelocity(Ball)
    local currentSpeed = VectorMagnitude(ballVel)
    local tracking = _G.AutoParryState.AbilityTracking
    local currentTime = tick()
    
    if currentSpeed < Config.FreezeBallSpeedThreshold then
        if not tracking.BallFrozen then
            tracking.BallFrozen = true
            tracking.FreezeStartTime = currentTime
            tracking.FreezeDetectedTime = currentTime
        end
        return true
    else
        if tracking.BallFrozen then
            tracking.BallFrozen = false
        end
        return false
    end
end

local function CheckTelekinesisAbility()
    if not Config.TelekinesisDetectionEnabled then return false end
    
    local Ball = GetCurrentBall()
    if not Ball then return false end
    
    local ballVel = _G.GetBallVelocity(Ball)
    local currentSpeed = VectorMagnitude(ballVel)
    local tracking = _G.AutoParryState.AbilityTracking
    local currentTime = tick()
    
    if tracking.BallFrozen and currentSpeed >= Config.TelekinesisVelocityThreshold then
        local currentTarget = nil
        local aliveFolder = workspace:FindFirstChild("Alive")
        if aliveFolder then
            for _, character in aliveFolder:GetChildren() do
                if character:FindFirstChild("Highlight") then
                    currentTarget = character.Name
                    break
                end
            end
        end
        
        if not tracking.TelekinesisActive then
            tracking.TelekinesisActive = true
            tracking.TelekinesisDetectedTime = currentTime
            tracking.TelekinesisTargetChanged = (currentTarget ~= tracking.PreTelekinesisTarget)
            return true
        end
    end
    
    if tracking.TelekinesisActive and (currentTime - tracking.TelekinesisDetectedTime) > 2.0 then
        tracking.TelekinesisActive = false
    end
    
    if IsTargeted() then
        tracking.PreTelekinesisTarget = _G.AutoParryState.LocalPlayer.Name
    end
    
    tracking.LastBallSpeed = currentSpeed
    
    return tracking.TelekinesisActive
end

local function ShouldParryTelekinesis()
    if not Config.TelekinesisDetectionEnabled then return false end
    
    local tracking = _G.AutoParryState.AbilityTracking
    local currentTime = tick()
    
    if tracking.TelekinesisActive and IsTargeted() then
        local timeSinceTelekinesis = currentTime - tracking.TelekinesisDetectedTime

        if timeSinceTelekinesis >= Config.TelekinesisParryDelay then
            return true
        end
    end
    
    return false
end

-- AERODYNAMIC SLASH VFX DETECTION
local function CheckAeroSlashVFX()
    if not Config.AeroDefenseEnabled or not Config.AeroDefense.useVFXDetection then
        return false
    end
    
    local Ball = GetCurrentBall()
    if not Ball then return false end
    
    local tracking = _G.AutoParryState.AbilityTracking
    local currentTime = tick()
    
    if tracking.AeroVFXDetected and (currentTime - tracking.AeroVFXDetectionTime) < 2.0 then
        return false
    end
    
    local hasVFX = Ball:FindFirstChild('AeroDynamicSlashVFX')
    if hasVFX then
        if not tracking.AeroVFXDetected then
            local aeroUserPos, calculatedDelay = FindAeroUserAndCalculateDelay()
            
            tracking.AeroTornadoStartTime = currentTime
            tracking.AeroVFXDetected = true
            tracking.AeroVFXDetectionTime = currentTime
            tracking.AeroUserPosition = aeroUserPos
            tracking.AeroCalculatedDelay = calculatedDelay
            return true
        end
    end
    
    return false
end

local function IsWithinTornadoDuration()
    local tracking = _G.AutoParryState.AbilityTracking
    
    if tracking.AeroTornadoStartTime == 0 then return false end
    
    local currentTime = tick()
    local timeSinceTornado = currentTime - tracking.AeroTornadoStartTime
    
    if timeSinceTornado < 2.5 then
        return true
    end
    
    if timeSinceTornado > 3.0 then
        tracking.AeroTornadoStartTime = 0
        tracking.AeroVFXDetected = false
    end
    
    return false
end

local function CheckAeroSlashParryVFX(ballPos, ballVel, playerPos, currentSpeed, currentTime)
    if not Config.AeroDefenseEnabled or not Config.AeroDefense.useVFXDetection then
        return false
    end
    
    local tracking = _G.AutoParryState.AbilityTracking
    local aeroConfig = Config.AeroDefense
    
    if not tracking.AeroVFXDetected then
        return false
    end
    
    if not IsTargeted() then
        return false
    end

    local timeSinceVFX = currentTime - tracking.AeroVFXDetectionTime
    local requiredDelay = tracking.AeroCalculatedDelay or aeroConfig.baseParryDelay

    if timeSinceVFX < requiredDelay then
        return false
    end

    if not IsWithinTornadoDuration() then
        tracking.AeroVFXDetected = false
        return false
    end

    if currentSpeed < aeroConfig.minSpeedForParry then
        return false
    end

    local distance = VectorMagnitude(ballPos - playerPos)
    local toPlayer = (playerPos - ballPos)
    local toPlayerMag = VectorMagnitude(toPlayer)

    if toPlayerMag < 0.01 then
        return false
    end

    local toPlayerNorm = toPlayer / toPlayerMag
    local ballDirNorm = ballVel / currentSpeed
    local alignment = toPlayerNorm.X * ballDirNorm.X + toPlayerNorm.Y * ballDirNorm.Y + toPlayerNorm.Z * ballDirNorm.Z

    if alignment >= aeroConfig.alignmentThreshold then
        tracking.AeroVFXDetected = false
        tracking.AeroTornadoStartTime = 0
        return true
    end

    return false
end

-- DYNAMIC CLICK SYSTEM
local function GetClickSettings(distance, approachVelocity)
    if not Config.DynamicClickRates then
        return 1, 50
    end
    
    if approachVelocity < 50 then
        return 1, 50
    end
    
    for _, zone in ipairs(Config.ClickRateZones) do
        local maxDist = zone[1]
        local clickCount = zone[2]
        local minDelay = zone[3]
        
        if distance <= maxDist then
            if approachVelocity < 200 and clickCount > 1 then
                clickCount = clickCount - 1
            end
            return clickCount, minDelay
        end
    end
    
    return 1, 50
end

local function GetSpeedAdjustedRapidDistance(speed)
    if not Config.SpeedBasedRapidParry then
        return 65
    end
    
    for i = #Config.SpeedRapidParryTiers, 1, -1 do
        local tier = Config.SpeedRapidParryTiers[i]
        local speedThreshold = tier[1]
        local maxDistance = tier[2]
        
        if speed >= speedThreshold then
            return maxDistance
        end
    end
    
    return 65
end

local function ExecuteDynamicClicks(distance, approachVelocity)
    local currentTime = tick()
    local timeSinceLastClick = (currentTime - _G.AutoParryState.DynamicClick.lastClickTime) * 1000
    
    if timeSinceLastClick < 50 then
        return false
    end
    
    mouse1click()
    
    _G.AutoParryState.DynamicClick.lastClickTime = currentTime
    _G.AutoParryState.DynamicClick.clickCount = 1
    
    return true
end

-- DISTANCE-SPEED CORRELATION
local function GetDistanceSpeedMultiplier(distance, speed)
    if not Config.UseDistanceSpeedCorrelation then
        return 1.0, 0
    end
    
    for _, range in ipairs(Config.DistanceSpeedRanges) do
        local minDist = range[1]
        local maxDist = range[2]
        local baseMultiplier = range[3]
        local speedScaling = range[4]
        
        if distance >= minDist and distance < maxDist then
            local speedAdjustment = speed * speedScaling
            return baseMultiplier, speedAdjustment
        end
    end
    
    return 1.0, 0
end

local function GetProgressiveDistanceMultiplier(distance)
    if not Config.ProgressiveDistanceEnabled then
        return 1.0
    end
    
    for _, range in ipairs(Config.ProgressiveDistanceRanges) do
        local maxDist = range[1]
        local multiplier = range[2]
        
        if distance <= maxDist then
            return multiplier
        end
    end
    
    return 1.0
end

-- ABILITY DETECTION
local function GetEquippedAbility()
    local currentTime = tick()
    if currentTime - _G.AutoParryState.AbilityTracking.LastAbilityCheck < 0.1 then
        return _G.AutoParryState.AbilityTracking.CurrentAbility
    end
    
    _G.AutoParryState.AbilityTracking.LastAbilityCheck = currentTime
    
    local player = _G.AutoParryState.LocalPlayer
    if player then
        local ability = player:GetAttribute("EquippedAbility")
        if ability then
            local abilityStr = tostring(ability)
            
            if abilityStr ~= _G.AutoParryState.AbilityTracking.CurrentAbility then
                _G.AutoParryState.AbilityTracking.CurrentAbility = abilityStr
                
                local abilityLower = abilityStr:lower()
                if abilityLower:find("infinity") or abilityLower:find("inf") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.Infinity = 0
                elseif abilityLower:find("singularity") or abilityLower:find("sing") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.Singularity = 0
                elseif abilityLower:find("raging") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.RagingDeflection = 0
                elseif abilityLower:find("calming") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.CalmingDeflection = 0
                elseif abilityLower:find("aerodynamic") or abilityLower:find("aero") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.AerodynamicSlash = 0
                elseif abilityLower:find("rapture") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.Rapture = 0
                elseif abilityLower:find("death") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.DeathSlash = 0
                elseif abilityLower:find("fury") or abilityLower:find("slash of fury") then
                    _G.AutoParryState.AbilityTracking.AbilityCooldowns.SlashOfFury = 0
                end
                
            end
            
            return abilityStr
        end
    end
    
    local character = player.Character
    if character then
        local ability = character:GetAttribute("EquippedAbility")
        if ability then
            return tostring(ability)
        end
    end
    
    return nil
end

local function PressQKey()
    keypress(0x51)
    keyrelease(0x51)
end

local function CanUseAbility(abilityName)
    local currentTime = tick()
    local cooldownEnd = _G.AutoParryState.AbilityTracking.AbilityCooldowns[abilityName] or 0
    
    if currentTime < cooldownEnd then
        return false, string.format("%.1fs", cooldownEnd - currentTime)
    end
    
    if currentTime - _G.AutoParryState.AbilityTracking.LastAutoPop < 0.2 then
        return false, "global CD"
    end
    
    return true, "ready"
end

local function UseAbility(abilityName, cooldownDuration)
    local canUse, reason = CanUseAbility(abilityName)
    if not canUse then
        return false
    end
    
    local currentTime = tick()
    PressQKey()
    
    local actualCooldown = cooldownDuration
    
    if abilityName == "Infinity" then
        actualCooldown = 28
    elseif abilityName == "Singularity" then
        actualCooldown = 20
    elseif abilityName == "RagingDeflection" then
        actualCooldown = 25
    elseif abilityName == "CalmingDeflection" then
        actualCooldown = 25
    elseif abilityName == "AerodynamicSlash" then
        actualCooldown = 30
    elseif abilityName == "Rapture" then
        actualCooldown = 30
    elseif abilityName == "DeathSlash" then
        actualCooldown = 13
    elseif abilityName == "SlashOfFury" then
        actualCooldown = 27
    end
    
    _G.AutoParryState.AbilityTracking.AbilityCooldowns[abilityName] = currentTime + actualCooldown
    _G.AutoParryState.AbilityTracking.LastAutoPop = currentTime

    if abilityName == "DeathSlash" and Config.AutoPopAbilities.DeathSlash.qteEnabled then
        task.spawn(function()
            task.wait(Config.AutoPopAbilities.DeathSlash.qteDelay)
            for i = 1, Config.AutoPopAbilities.DeathSlash.qtePressCount do
                mouse1click()
                if i < Config.AutoPopAbilities.DeathSlash.qtePressCount then
                    task.wait(0.05)
                end
            end
        end)
    end

    if abilityName == "SlashOfFury" then
        
        _G.AutoParryState.AbilityTracking.SoFActive = true
        _G.AutoParryState.AbilityTracking.SoFStartTime = currentTime
        _G.AutoParryState.AbilityTracking.SoFPreparedForReturn = false
        
        task.spawn(function()
            task.wait(0.3)
            
            for i = 1, 38 do
                mouse1click()
                
                if i < 38 then
                    local delay = i <= 23 and 0.100 or 0.050
                    task.wait(delay)
                end
            end
            
            _G.AutoParryState.AbilityTracking.SoFActive = false

            if Config.AutoPopAbilities.SlashOfFury.prepareForReturn then
                _G.AutoParryState.AbilityTracking.SoFPreparedForReturn = true

                task.spawn(function()
                    task.wait(5.0)
                    if _G.AutoParryState.AbilityTracking.SoFPreparedForReturn then
                        _G.AutoParryState.AbilityTracking.SoFPreparedForReturn = false
                    end
                end)
            end
        end)
    end
    
    pcall(function()
        send_notification("âš¡ " .. abilityName)
    end)
    
    return true
end

-- CACHE UPDATES
RunService.PreLocal:Connect(function()
    if not _G.AutoParryState.ThreadRunning then return end
    
    pcall(function()
        if _G.AutoParryState.LocalPlayer then
            _G.AutoParryState.CachedCharacter = _G.AutoParryState.LocalPlayer.Character
            if _G.AutoParryState.CachedCharacter then
                _G.AutoParryState.CachedHRP = _G.AutoParryState.CachedCharacter:FindFirstChild("HumanoidRootPart")
            end
        end
        
        _G.AutoParryState.CachedBallsFolder = workspace:FindFirstChild("Balls")
        _G.AutoParryState.CachedAliveFolder = workspace:FindFirstChild("Alive")
        
        if _G.AutoParryState.CachedAliveFolder then
            _G.AutoParryState.CachedPlayerModel = _G.AutoParryState.CachedAliveFolder:FindFirstChild(_G.AutoParryState.LocalPlayer.Name)
        end
    end)
end)

-- TARGET DETECTION
RunService.PreLocal:Connect(function()
    if not _G.AutoParryState.ThreadRunning then return end
    
    pcall(function()
        local isTargeted = IsTargeted()
        _G.AutoParryState.BallData.isTargeted = isTargeted
        
        if not isTargeted then
            _G.AutoParryState.Clicked = false
        end
        
        if isTargeted and _G.AutoParryState.AbilityTracking.BallFrozen then
            if _G.AutoParryState.Clicked then
                _G.AutoParryState.Clicked = false
            end
        end
    end)
end)

-- AUTOCLICKER
local AutoclickerLastClick = 0

RunService.PreLocal:Connect(function()
    if not _G.AutoParryState.AutoclickerMode then return end

    local currentTime = tick()
    if currentTime - AutoclickerLastClick < AutoclickerSettings.ClickInterval then return end

    AutoclickerLastClick = currentTime

    mouse1click()
    mouse1click()
    mouse1click()
    mouse1click()
end)

-- TRIGGER BOT
RunService.PreLocal:Connect(function()
    if not TBSettings.Enabled then
        TBSettings.HasClicked = false
        return
    end

    local isTargeting = IsTargeted()

    if isTargeting then
        if not TBSettings.HasClicked then
            local currentTime = tick()
            if (currentTime - TBSettings.LastClickTime) >= (TBSettings.ClickDelay / 1000) then
                mouse1click()
                TBSettings.LastClickTime = currentTime
                TBSettings.HasClicked = true
            end
        end
    else
        TBSettings.HasClicked = false
    end
end)

-- MARTYRDOM TRACKING
RunService.PreLocal:Connect(function()
    if not _G.AutoParryState.ThreadRunning or not Config.MartyrdomDetectionEnabled then return end
    
    pcall(function()
        local myPos = GetPlayerPosition()
        if not myPos then return end
        
        local tracking = _G.AutoParryState.AbilityTracking
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= _G.AutoParryState.LocalPlayer and player.Character then
                local playerName = player.Name
                local health = GetPlayerHealth(player)
                local distance = GetDistanceToPlayer(player.Character)
                local hasMartyrdom = HasMartyrdomAbility(player)
                
                tracking.LowHealthPlayers[playerName] = {
                    health = health,
                    distance = distance,
                    hasMartyrdom = hasMartyrdom,
                    time = tick()
                }
                
                local isDead = health <= 0
                local wasAlive = tracking.LastPlayerStates[playerName]
                
                if isDead and wasAlive and hasMartyrdom and distance <= Config.MartyrdomSafeDistance * 2 then
                    local hrp = player.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        TrackMartyrdomExplosion(playerName, hrp.Position, tick())
                    end
                end
                
                tracking.LastPlayerStates[playerName] = not isDead
            end
        end
        
        local currentTime = tick()
        for playerName, data in pairs(tracking.LowHealthPlayers) do
            if currentTime - data.time > 5 then
                tracking.LowHealthPlayers[playerName] = nil
            end
        end
    end)
end)

-- BALL TRACKING
RunService.PreLocal:Connect(function()
    if not _G.AutoParryState.ThreadRunning then return end
    
    pcall(function()
        local Ball = GetCurrentBall()
        local currentTime = tick()
        
        if not Ball then
            if _G.AutoParryState.BallData.ballExists then
                _G.AutoParryState.BallData.ballExists = false
            end
            _G.AutoParryState.BallTracking.lastBallSpeed = 0
            _G.AutoParryState.BallTracking.lastBallDistance = 999
            _G.AutoParryState.BallData.lastBallPosition = nil
            _G.AutoParryState.BallData.approachVelocity = 0
            _G.AutoParryState.BallTracking.peakSpeed = 0
            return
        end

        if not _G.AutoParryState.BallData.ballExists then
            _G.AutoParryState.BallData.ballExists = true
            _G.AutoParryState.BallData.ballRespawnTime = currentTime
            _G.AutoParryState.Clicked = false
            _G.AutoParryState.LastParryTime = 0
            _G.AutoParryState.BallTracking.peakSpeed = 0
            _G.AutoParryState.BallTracking.peakSpeedTime = 0
        end
        
        local ballVel = _G.GetBallVelocity(Ball)
        local currentSpeed = VectorMagnitude(ballVel)
        local lastSpeed = _G.AutoParryState.BallTracking.lastBallSpeed
        local speedDifference = currentSpeed - lastSpeed
        
        local timeSinceRespawn = currentTime - _G.AutoParryState.BallData.ballRespawnTime
        if timeSinceRespawn < 0.5 and currentSpeed < 100 then
            _G.AutoParryState.BallTracking.peakSpeed = 0
            _G.AutoParryState.BallTracking.peakSpeedTime = 0
        end
        
        CheckFreezeAbility()
        CheckTelekinesisAbility()
        CheckAeroSlashVFX()
        DetectBallFreeze(currentSpeed, currentTime)
        DetectTelekinesis(currentSpeed, currentTime)
        
        local peakSpeed = _G.AutoParryState.BallTracking.peakSpeed
        local peakSpeedTime = _G.AutoParryState.BallTracking.peakSpeedTime
        
        if currentSpeed > peakSpeed then
            peakSpeed = currentSpeed
            peakSpeedTime = currentTime
            _G.AutoParryState.BallTracking.peakSpeed = peakSpeed
            _G.AutoParryState.BallTracking.peakSpeedTime = peakSpeedTime
        end
        
        if currentTime - peakSpeedTime > _G.AutoParryState.BallTracking.speedSmoothWindow then
            peakSpeed = currentSpeed
            peakSpeedTime = currentTime
            _G.AutoParryState.BallTracking.peakSpeed = peakSpeed
            _G.AutoParryState.BallTracking.peakSpeedTime = peakSpeedTime
        end
        
        local playerPos = GetPlayerPosition()
        local approachVelocity = 0
        local distance = 999
        
        if playerPos then
            local ballPos = Ball.Position
            distance = VectorMagnitude(ballPos - playerPos)
            _G.AutoParryState.BallTracking.lastBallDistance = distance
            
            local lastBallPos = _G.AutoParryState.BallData.lastBallPosition
            if lastBallPos then
                local lastDistance = VectorMagnitude(lastBallPos - playerPos)
                local distanceChange = lastDistance - distance
                approachVelocity = distanceChange / 0.016
                approachVelocity = MAX(0, approachVelocity)
                _G.AutoParryState.BallData.approachVelocity = approachVelocity
            end
            
            _G.AutoParryState.BallData.lastBallPosition = ballPos
        end
        
        _G.AutoParryState.BallTracking.lastBallSpeed = currentSpeed
        _G.AutoParryState.BallTracking.lastCheckTime = currentTime
        
        local isTargeted = IsTargeted()
        
        -- SLASH OF FURY INSTANT RETURN
        if _G.AutoParryState.AbilityTracking.SoFPreparedForReturn and isTargeted then
            if currentSpeed >= 350 and distance < 80 and not _G.AutoParryState.Clicked then
                mouse1click()
                _G.AutoParryState.Clicked = true
                _G.AutoParryState.LastParryTime = currentTime
                _G.AutoParryState.AbilityTracking.SoFPreparedForReturn = false
            end
        end

        -- Velocity spike detection (DISABLED during Aero)
        if not _G.AutoParryState.AbilityTracking.AeroVFXDetected then
            local spikeThreshold = 200
            if peakSpeed >= 600 then
                spikeThreshold = 150
            end

            local timeSinceLastParry = currentTime - (_G.AutoParryState.LastParryTime or 0)
            local allowSpikeDetection = timeSinceLastParry > 0.3

            if allowSpikeDetection and speedDifference >= spikeThreshold and lastSpeed > 30 and distance > 50 and isTargeted and not _G.AutoParryState.Clicked and Config.AutoParryEnabled and not _G.AutoParryState.AutoclickerMode then
                mouse1click()
                _G.AutoParryState.Clicked = true
                _G.AutoParryState.LastParryTime = currentTime
            end
        end
    end)
end)

-- OLD CLASH MODE FUNCTIONS (from old script)
local function RecordParry(speed)
    if speed < Config.ClashMinSpeed then return end
    
    local now = tick()
    table.insert(_G.AutoParryState.ParryHistory, {
        time = now,
        speed = speed
    })
    
    -- Clean up old parries
    local cutoffTime = now - Config.ClashActivationTime
    for i = #_G.AutoParryState.ParryHistory, 1, -1 do
        if _G.AutoParryState.ParryHistory[i].time < cutoffTime then
            table.remove(_G.AutoParryState.ParryHistory, i)
        end
    end
    
    -- Update last clash parry time if in clash mode
    if _G.AutoParryState.ClashMode then
        _G.AutoParryState.LastClashParryTime = now
    end
end

local function CheckClashActivation()
    local now = tick()
    
    -- Count recent parries
    local recentParries = 0
    local cutoffTime = now - Config.ClashActivationTime
    
    for _, parry in ipairs(_G.AutoParryState.ParryHistory) do
        if parry.time >= cutoffTime then
            recentParries = recentParries + 1
        end
    end
    
    -- Activate clash mode
    if not _G.AutoParryState.ClashMode and recentParries >= Config.ClashMinParries then
        _G.AutoParryState.ClashMode = true
        _G.AutoParryState.ClashModeActivatedAt = now
        _G.AutoParryState.LastClashParryTime = now
        
        pcall(function()
            send_notification("ðŸ”¥ CLASH MODE ACTIVATED")
        end)
        return true
    end
    
    -- Deactivate if no recent parries
    if _G.AutoParryState.ClashMode then
        local timeSinceLastParry = now - _G.AutoParryState.LastClashParryTime
        
        if timeSinceLastParry > Config.ClashDeactivationTime then
            _G.AutoParryState.ClashMode = false
            
            pcall(function()
                send_notification("CLASH MODE ENDED")
            end)
            return false
        end
    end
    
    return _G.AutoParryState.ClashMode
end

-- OLD DYNAMIC PARRY TIME FUNCTION (from old script)
local function GetParryTime(speed)
    if not Config.DynamicParryTiming then
        return Config.BaseParryTime
    end
    
    -- Clamp speed to range
    local clampedSpeed = math.max(Config.SpeedForMaxTiming, math.min(Config.SpeedForMinTiming, speed))
    
    -- Linear interpolation between max and min timing
    local speedRange = Config.SpeedForMinTiming - Config.SpeedForMaxTiming
    local timeRange = Config.ParryTimeMax - Config.ParryTimeMin
    local speedOffset = clampedSpeed - Config.SpeedForMaxTiming
    
    local parryTime = Config.ParryTimeMax - (speedOffset / speedRange) * timeRange
    
    return parryTime
end

-- OLD EMERGENCY PARRY FUNCTION (from old script)
local function EmergencyParry(distance, speed)
    if distance <= Config.EmergencyDistance then
        local now = tick()
        if now - _G.AutoParryState.LastParryTime >= Config.EmergencyParryCooldown then
            if not _G.AutoParryState.Clicked then
                mouse1click()
                _G.AutoParryState.LastParryTime = now
                _G.AutoParryState.Clicked = true
                
                RecordParry(speed)
                return true
            end
        end
    end
    return false
end

-- OLD CLASH MODE SPAM THREAD (from old script)
task.spawn(function()
    while true do
        task.wait(Config.ClashSpamDelay)
        if Config.AutoClashEnabled then
            pcall(function()
                local isTargeted = IsTargeted()
                local now = tick()
                
                if _G.AutoParryState.ClashMode then
                    local timeSinceLastParry = now - _G.AutoParryState.LastClashParryTime
                    
                    if timeSinceLastParry > Config.ClashDeactivationTime then
                        _G.AutoParryState.ClashMode = false
                    elseif isTargeted and not _G.AutoParryState.AbilityTracking.BallFrozen then
                        -- Continuous spam clicks
                        mouse1click()
                        keypress(0x46) -- F key
                        keyrelease(0x46)
                    end
                end
            end)
        end
    end
end)

-- INTEGRATED AUTO-PARRY LOGIC (OLD + NEW)
RunService.PreLocal:Connect(function()
    if not _G.AutoParryState.ThreadRunning or not Config.AutoParryEnabled or _G.AutoParryState.AutoclickerMode then
        return
    end
    
    pcall(function()
        local currentTime = tick()
        local isTargeted = _G.AutoParryState.BallData.isTargeted
        
        -- Don't interfere with Slash of Fury
        if _G.AutoParryState.AbilityTracking.SoFActive then
            return
        end
        
        -- MARTYRDOM SAFETY
        if ShouldAvoidMartyrdom() then
            return
        end
        
        -- FREEZE ABILITY
        if ShouldParryFrozenBall() then
            local Ball = GetCurrentBall()
            if Ball and not _G.AutoParryState.Clicked then
                mouse1click()
                _G.AutoParryState.Clicked = true
                _G.AutoParryState.LastParryTime = currentTime
                return
            end
        end

        if _G.AutoParryState.AbilityTracking.FreezeJustExpired then
            local timeSinceExpire = currentTime - _G.AutoParryState.AbilityTracking.FreezeExpireTime

            if timeSinceExpire > 0.2 then
                _G.AutoParryState.AbilityTracking.FreezeJustExpired = false
            end
        end
        
        -- TELEKINESIS
        if ShouldParryTelekinesis() then
            local Ball = GetCurrentBall()
            if Ball and not _G.AutoParryState.Clicked then
                mouse1click()
                _G.AutoParryState.Clicked = true
                _G.AutoParryState.LastParryTime = currentTime
                
                _G.AutoParryState.AbilityTracking.TelekinesisActive = false
                
                return
            end
        end
        
        -- AERODYNAMIC SLASH VFX
        if _G.AutoParryState.AbilityTracking.AeroVFXDetected then
            local Ball = GetCurrentBall()
            local playerPos = GetPlayerPosition()
            
            if Ball and playerPos and not _G.AutoParryState.Clicked then
                local ballPos = Ball.Position
                local ballVel = _G.GetBallVelocity(Ball)
                local currentSpeed = VectorMagnitude(ballVel)
                
                if CheckAeroSlashParryVFX(ballPos, ballVel, playerPos, currentSpeed, currentTime) then
                    mouse1click()
                    _G.AutoParryState.Clicked = true
                    _G.AutoParryState.LastParryTime = currentTime
                    
                    pcall(function()
                        send_notification("ðŸŒªï¸ Aero Defended!")
                    end)
                end
            end
            
            return
        end
        
        -- Singularity Cape check
        local hasCape = HasSingularityCape()
        if hasCape then
            local Ball = GetCurrentBall()
            if Ball and isTargeted then
                local ballVel = _G.GetBallVelocity(Ball)
                local speed = VectorMagnitude(ballVel)
                local playerPos = GetPlayerPosition()
                
                if playerPos then
                    local ballPos = Ball.Position
                    local distance = VectorMagnitude(ballPos - playerPos)

                    if not (speed > 300 and distance < 100) then
                        return
                    end
                else
                    return
                end
            else
                return
            end
        end
        
        local Ball = GetCurrentBall()
        local playerPos = GetPlayerPosition()
        
        if not Ball or not playerPos or not isTargeted then
            return
        end
        
        local ballPos = Ball.Position
        local ballVel = _G.GetBallVelocity(Ball)
        local currentSpeed = VectorMagnitude(ballVel)
        local distance = VectorMagnitude(ballPos - playerPos)
        local approachVelocity = _G.AutoParryState.BallData.approachVelocity or 0
        
        if currentSpeed <= Config.MinParrySpeed then return end
        
        local speedForMultiplier = _G.AutoParryState.BallTracking.peakSpeed
        if speedForMultiplier < currentSpeed then
            speedForMultiplier = currentSpeed
        end
        
        -- CHECK CLASH MODE
        CheckClashActivation()
        
        -- CLASH MODE SPAM (handled by separate thread, skip normal parry)
        if Config.AutoClashEnabled and _G.AutoParryState.ClashMode and isTargeted and not _G.AutoParryState.Clicked then
            return -- Let spam thread handle it
        end
        
        -- OLD EMERGENCY PARRY (from old script)
        if EmergencyParry(distance, currentSpeed) then
            return
        end
        
        -- OLD PARRY COOLDOWN CHECK (from old script)
        if currentTime - _G.AutoParryState.LastParryTime < Config.ParryCooldown then
            return
        end
        
        -- Skip if already clicked
        if _G.AutoParryState.Clicked then
            return
        end
        
        -- OLD DIRECTION CHECK (from old script)
        if distance > Config.IgnoreDirectionUnderDistance then
            local dirToPlayer_X = (playerPos.X - ballPos.X) / distance
            local dirToPlayer_Y = (playerPos.Y - ballPos.Y) / distance
            local dirToPlayer_Z = (playerPos.Z - ballPos.Z) / distance
            
            local velDir_X = ballVel.X / currentSpeed
            local velDir_Y = ballVel.Y / currentSpeed
            local velDir_Z = ballVel.Z / currentSpeed
            
            local dotProduct = (velDir_X * dirToPlayer_X) + (velDir_Y * dirToPlayer_Y) + (velDir_Z * dirToPlayer_Z)
            
            if dotProduct < Config.MinDirectionDotProduct then
                return
            end
        end
        
        -- Calculate time to reach (OLD METHOD)
        local adjustedDistance = math.max(0, distance - Config.ParryBufferDistance)
        local timeToReach = adjustedDistance / currentSpeed
        
        -- Get OLD dynamic parry time based on speed
        local parryTime = GetParryTime(currentSpeed)
        
        -- Parry if within time window
        if timeToReach <= parryTime then
            local equippedAbility = GetEquippedAbility()
            local abilityUsed = false
            
            if equippedAbility then
                local abilityLower = equippedAbility:lower()
                
                -- INFINITY
                if (abilityLower:find("infinity") or abilityLower:find("inf")) and Config.AutoPopAbilities.Infinity.enabled then
                    if UseAbility("Infinity", 28) then
                        _G.AutoParryState.Clicked = true
                        abilityUsed = true
                        RecordParry(currentSpeed)
                    end
                end

                -- RAGING DEFLECTION
                if not abilityUsed and abilityLower:find("raging") and Config.AutoPopAbilities.RagingDeflection.enabled then
                    if UseAbility("RagingDeflection", 35) then
                        _G.AutoParryState.Clicked = true
                        abilityUsed = true
                        RecordParry(currentSpeed)
                    end
                end

                -- CALMING DEFLECTION
                if not abilityUsed and abilityLower:find("calming") and Config.AutoPopAbilities.CalmingDeflection.enabled then
                    if UseAbility("CalmingDeflection", 35) then
                        _G.AutoParryState.Clicked = true
                        abilityUsed = true
                        RecordParry(currentSpeed)
                    end
                end

                -- SINGULARITY
                if not abilityUsed and (abilityLower:find("singularity") or abilityLower:find("sing")) and Config.AutoPopAbilities.Singularity.enabled then
                    if Config.AutoPopAbilities.Singularity.useOnParry then
                        if UseAbility("Singularity", 24) then
                            _G.AutoParryState.Clicked = true
                            abilityUsed = true
                            RecordParry(currentSpeed)
                        end
                    end
                end

                -- DEATH SLASH
                if not abilityUsed and abilityLower:find("death") and Config.AutoPopAbilities.DeathSlash.enabled then
                    if UseAbility("DeathSlash", 13) then
                        _G.AutoParryState.Clicked = true
                        abilityUsed = true
                        RecordParry(currentSpeed)
                    end
                end

                -- AERODYNAMIC SLASH
                if not abilityUsed and (abilityLower:find("aerodynamic") or abilityLower:find("aero")) and Config.AutoPopAbilities.AerodynamicSlash.enabled then
                    if Config.AutoPopAbilities.AerodynamicSlash.useOnParry then
                        if UseAbility("AerodynamicSlash", 40) then
                            _G.AutoParryState.Clicked = true
                            abilityUsed = true
                            RecordParry(currentSpeed)
                        end
                    end
                end

                -- RAPTURE
                if not abilityUsed and abilityLower:find("rapture") and Config.AutoPopAbilities.Rapture.enabled then
                    if Config.AutoPopAbilities.Rapture.useOnParry then
                        if UseAbility("Rapture", 30) then
                            _G.AutoParryState.Clicked = true
                            abilityUsed = true
                            RecordParry(currentSpeed)
                        end
                    end
                end

                -- SLASH OF FURY
                if not abilityUsed and (abilityLower:find("fury") or abilityLower:find("slash of fury")) and Config.AutoPopAbilities.SlashOfFury.enabled then
                    if Config.AutoPopAbilities.SlashOfFury.useOnParry then
                        if distance >= Config.AutoPopAbilities.SlashOfFury.activateMinDistance and
                           distance <= Config.AutoPopAbilities.SlashOfFury.activateMaxDistance and
                           currentSpeed >= Config.AutoPopAbilities.SlashOfFury.activateMinSpeed then
                            if UseAbility("SlashOfFury", 27) then
                                _G.AutoParryState.Clicked = true
                                abilityUsed = true
                                RecordParry(currentSpeed)
                            end
                        end
                    end
                end
            end

            -- Normal parry if no ability used
            if not abilityUsed then
                mouse1click()
                _G.AutoParryState.LastParryTime = currentTime
                _G.AutoParryState.Clicked = true
                
                RecordParry(currentSpeed)
            end
        end
    end)
end)

-- UI (Same as before - keeping the entire UI from the new script)
local UiLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/xposn/ui/refs/heads/main/UiLib.lua"))()

local camera = game:GetService("Workspace").CurrentCamera
local screenSize = camera and camera.ViewportSize or Vector2.new(1920, 1080)
local menuWidth = 400
local menuHeight = 400
local centerX = (screenSize.X - menuWidth) / 2
local centerY = (screenSize.Y - menuHeight) / 2

local Window = UiLib:CreateWindow({
    Title = "Who's AP? (INTEGRATED)                                                w6lv (UI By X)",
    Subtitle = "F3 to toggle - Old AP + Old Clash",
    Position = Vector2.new(centerX, centerY),
    Width = menuWidth,
    ToggleKey = "F3"
})

Window:SetTheme({
    Accent = Color3.fromRGB(130, 90, 255),
    On = Color3.fromRGB(0, 255, 180),
    Off = Color3.fromRGB(255, 60, 85)
})

local MainTab = Window:CreateTab("Main")

local AutoParryToggle = MainTab:CreateToggle({
    Name = "Auto Parry",
    Default = Config.AutoParryEnabled,
    Tooltip = "OLD Auto-Parry Logic (Dynamic Timing)",
    Callback = function(value)
        Config.AutoParryEnabled = value
    end
})

local AutoParryKeybind = MainTab:CreateKeybind({
    Name = "AP Keybind",
    Default = Keybinds.ToggleAutoParry,
    Mode = "toggle",
    LinkedToggle = AutoParryToggle,
    Tooltip = "Toggle auto parry on/off",
    Callback = function(key)
        Keybinds.ToggleAutoParry = key
    end,
    ActivateCallback = function(active)
        Config.AutoParryEnabled = active
    end
})

MainTab:CreateDivider()

local TBToggle = MainTab:CreateToggle({
    Name = "Trigger Bot",
    Default = TBSettings.Enabled,
    Tooltip = "Auto-click when holding TB key",
    Callback = function(value)
        TBSettings.Enabled = value
    end
})

local TBKeybind = MainTab:CreateKeybind({
    Name = "TB Keybind",
    Default = TBSettings.Keybind,
    Mode = "toggle",
    LinkedToggle = TBToggle,
    Tooltip = "Toggle trigger bot on/off",
    Callback = function(key)
        TBSettings.Keybind = key
    end,
    ActivateCallback = function(active)
        TBSettings.Enabled = active
    end
})

local TBDelaySlider = MainTab:CreateSlider({
    Name = "Click Delay",
    Min = 10,
    Max = 200,
    Default = TBSettings.ClickDelay,
    Step = 1,
    Suffix = "ms",
    Tooltip = "Delay between trigger bot clicks",
    Callback = function(value)
        TBSettings.ClickDelay = value
    end
})

MainTab:CreateDivider()

local AutoclickerToggle = MainTab:CreateToggle({
    Name = "Autoclicker",
    Default = _G.AutoParryState.AutoclickerMode,
    Tooltip = "Rapid click mode",
    Callback = function(value)
        _G.AutoParryState.AutoclickerMode = value
    end
})

local AutoclickerKeybind = MainTab:CreateKeybind({
    Name = "AC Keybind",
    Default = Keybinds.ToggleAutoclicker,
    Mode = "toggle",
    LinkedToggle = AutoclickerToggle,
    Tooltip = "Toggle autoclicker on/off",
    Callback = function(key)
        Keybinds.ToggleAutoclicker = key
    end,
    ActivateCallback = function(active)
        _G.AutoParryState.AutoclickerMode = active
    end
})

-- Abilities Tab
local AbilitiesTab = Window:CreateTab("Abilities")

AbilitiesTab:CreateLabel({ Text = "ESP" })

AbilitiesTab:CreateToggle({
    Name = "Ability ESP",
    Default = ESPSettings.Enabled,
    Tooltip = "Show enemy abilities above heads",
    Callback = function(value)
        ESPSettings.Enabled = value
    end
})

AbilitiesTab:CreateColorpicker({
    Name = "ESP Color",
    Default = ESPSettings.AbilityColor,
    Tooltip = "Color of ability ESP text",
    Callback = function(color)
        ESPSettings.AbilityColor = color
    end
})

AbilitiesTab:CreateSlider({
    Name = "ESP Text Size",
    Min = 10,
    Max = 24,
    Default = ESPSettings.TextSize,
    Step = 1,
    Tooltip = "Size of ESP text",
    Callback = function(value)
        ESPSettings.TextSize = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Show Distance",
    Default = ESPSettings.ShowDistance,
    Tooltip = "Show distance to players",
    Callback = function(value)
        ESPSettings.ShowDistance = value
    end
})

AbilitiesTab:CreateColorpicker({
    Name = "Distance Color",
    Default = ESPSettings.DistanceColor,
    Tooltip = "Color of distance text",
    Callback = function(color)
        ESPSettings.DistanceColor = color
    end
})

AbilitiesTab:CreateDivider()
AbilitiesTab:CreateLabel({ Text = "Auto Abilities" })

AbilitiesTab:CreateToggle({
    Name = "Infinity",
    Default = Config.AutoPopAbilities.Infinity.enabled,
    Tooltip = "Auto-use Infinity ability",
    Callback = function(value)
        Config.AutoPopAbilities.Infinity.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Raging Deflection",
    Default = Config.AutoPopAbilities.RagingDeflection.enabled,
    Tooltip = "Auto-use Raging Deflection",
    Callback = function(value)
        Config.AutoPopAbilities.RagingDeflection.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Calming Deflection",
    Default = Config.AutoPopAbilities.CalmingDeflection.enabled,
    Tooltip = "Auto-use Calming Deflection",
    Callback = function(value)
        Config.AutoPopAbilities.CalmingDeflection.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Singularity",
    Default = Config.AutoPopAbilities.Singularity.enabled,
    Tooltip = "Auto-use Singularity",
    Callback = function(value)
        Config.AutoPopAbilities.Singularity.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Aerodynamic Slash",
    Default = Config.AutoPopAbilities.AerodynamicSlash.enabled,
    Tooltip = "Auto-use Aero Slash",
    Callback = function(value)
        Config.AutoPopAbilities.AerodynamicSlash.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Rapture",
    Default = Config.AutoPopAbilities.Rapture.enabled,
    Tooltip = "Auto-use Rapture",
    Callback = function(value)
        Config.AutoPopAbilities.Rapture.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Death Slash",
    Default = Config.AutoPopAbilities.DeathSlash.enabled,
    Tooltip = "Auto-use Death Slash",
    Callback = function(value)
        Config.AutoPopAbilities.DeathSlash.enabled = value
    end
})

AbilitiesTab:CreateToggle({
    Name = "Slash of Fury",
    Default = Config.AutoPopAbilities.SlashOfFury.enabled,
    Tooltip = "Auto-use Slash of Fury (38 clicks)",
    Callback = function(value)
        Config.AutoPopAbilities.SlashOfFury.enabled = value
    end
})

-- Settings Tab
local SettingsTab = Window:CreateTab("Settings")

SettingsTab:CreateLabel({ Text = "OLD Auto-Parry Timing" })

SettingsTab:CreateSlider({
    Name = "Base Parry Time",
    Min = 0.1,
    Max = 1.0,
    Default = Config.BaseParryTime,
    Step = 0.01,
    Suffix = "s",
    Tooltip = "Base time before parry (OLD)",
    Callback = function(value)
        Config.BaseParryTime = value
    end
})

SettingsTab:CreateSlider({
    Name = "Parry Time Min",
    Min = 0.05,
    Max = 0.5,
    Default = Config.ParryTimeMin,
    Step = 0.01,
    Suffix = "s",
    Tooltip = "Minimum parry time (very fast balls)",
    Callback = function(value)
        Config.ParryTimeMin = value
    end
})

SettingsTab:CreateSlider({
    Name = "Parry Time Max",
    Min = 0.2,
    Max = 1.0,
    Default = Config.ParryTimeMax,
    Step = 0.01,
    Suffix = "s",
    Tooltip = "Maximum parry time (slow balls)",
    Callback = function(value)
        Config.ParryTimeMax = value
    end
})

SettingsTab:CreateSlider({
    Name = "Speed for Min Timing",
    Min = 200,
    Max = 800,
    Default = Config.SpeedForMinTiming,
    Step = 10,
    Suffix = " speed",
    Tooltip = "Speed at which minimum timing is used",
    Callback = function(value)
        Config.SpeedForMinTiming = value
    end
})

SettingsTab:CreateSlider({
    Name = "Speed for Max Timing",
    Min = 50,
    Max = 300,
    Default = Config.SpeedForMaxTiming,
    Step = 10,
    Suffix = " speed",
    Tooltip = "Speed at which maximum timing is used",
    Callback = function(value)
        Config.SpeedForMaxTiming = value
    end
})

SettingsTab:CreateSlider({
    Name = "Emergency Distance",
    Min = 5,
    Max = 30,
    Default = Config.EmergencyDistance,
    Step = 1,
    Suffix = " studs",
    Tooltip = "OLD Emergency parry distance",
    Callback = function(value)
        Config.EmergencyDistance = value
    end
})

SettingsTab:CreateDivider()

SettingsTab:CreateLabel({ Text = "OLD Clash System" })

SettingsTab:CreateToggle({
    Name = "Enable Auto-Clash",
    Default = Config.AutoClashEnabled,
    Tooltip = "OLD Clash system with spam thread",
    Callback = function(value)
        Config.AutoClashEnabled = value
    end
})

SettingsTab:CreateSlider({
    Name = "Clash Min Parries",
    Min = 2,
    Max = 5,
    Default = Config.ClashMinParries,
    Step = 1,
    Suffix = " parries",
    Tooltip = "Parries needed to activate clash",
    Callback = function(value)
        Config.ClashMinParries = value
    end
})

SettingsTab:CreateSlider({
    Name = "Clash Activation Time",
    Min = 0.5,
    Max = 2.0,
    Default = Config.ClashActivationTime,
    Step = 0.1,
    Suffix = "s",
    Tooltip = "Time window to count parries",
    Callback = function(value)
        Config.ClashActivationTime = value
    end
})

SettingsTab:CreateSlider({
    Name = "Clash Duration",
    Min = 1.0,
    Max = 5.0,
    Default = Config.ClashDeactivationTime,
    Step = 0.5,
    Suffix = "s",
    Tooltip = "How long clash stays active",
    Callback = function(value)
        Config.ClashDeactivationTime = value
    end
})

SettingsTab:CreateSlider({
    Name = "Clash Min Speed",
    Min = 30,
    Max = 100,
    Default = Config.ClashMinSpeed,
    Step = 5,
    Suffix = " speed",
    Tooltip = "Minimum speed to count for clash",
    Callback = function(value)
        Config.ClashMinSpeed = value
    end
})

SettingsTab:CreateDivider()

SettingsTab:CreateToggle({
    Name = "Show Keybind List",
    Default = false,
    Tooltip = "Show floating keybind panel",
    Callback = function(value)
        if value then
            Window:ShowKeybindList()
        else
            Window:HideKeybindList()
        end
    end
})

SettingsTab:CreateDivider()
SettingsTab:CreateLabel({ Text = "Profiles" })

local function GetProfileOptions()
    local profiles = Window:GetProfiles()
    local options = {"Default"}
    for _, profile in ipairs(profiles) do
        table.insert(options, profile)
    end
    return options
end

local ProfilesDropdown = SettingsTab:CreateDropdown({
    Name = "Profile",
    Options = GetProfileOptions(),
    Default = "Default",
    Callback = function(value)
    end
})

local ProfileNameInput = SettingsTab:CreateTextInput({
    Name = "Profile Name",
    Default = "MyProfile",
    Placeholder = "Enter name...",
    Callback = function(text)
    end
})

SettingsTab:CreateButton({
    Name = "Save Profile",
    Callback = function()
        local name = ProfileNameInput.Value
        if name and name ~= "" then
            if Window:SaveProfile(name) then
                Window:Notify("Saved: " .. name, 2)
                ProfilesDropdown.Options = GetProfileOptions()
            else
                Window:Notify("Save failed", 2)
            end
        else
            Window:Notify("Enter name first", 2)
        end
    end
})

SettingsTab:CreateButton({
    Name = "Load Profile",
    Callback = function()
        local name = ProfilesDropdown.Value
        if name == "Clear" then
            Window:ResetToDefaults()
            Window:Notify("Turn Everything Off", 2)
        elseif name then
            if Window:LoadProfile(name) then
                Window:Notify("Loaded: " .. name, 2)
            else
                Window:Notify("Load failed", 2)
            end
        end
    end
})

SettingsTab:CreateButton({
    Name = "Delete Profile",
    Callback = function()
        local name = ProfilesDropdown.Value
        if name and name ~= "Default" then
            if Window:DeleteProfile(name) then
                Window:Notify("Deleted: " .. name, 2)
                ProfilesDropdown.Options = GetProfileOptions()
                ProfilesDropdown:Set("Default")
            else
                Window:Notify("Delete failed", 2)
            end
        end
    end
})

-- ESP (Same as before)
RunService.Render:Connect(function()
    pcall(function()
        local camera = workspace.CurrentCamera
        if not camera then return end
        
        if Config.ShowCurveIndicator then
            local ball = GetCurrentBall()
            if ball then
                local playerPos = GetPlayerPosition()
                if playerPos then
                    local distance = math.floor(VectorMagnitude(ball.Position - playerPos))
                    local ballVel = _G.GetBallVelocity(ball)
                    local speed = math.floor(VectorMagnitude(ballVel))
                    
                    local screenPos, onScreen = camera:WorldToScreenPoint(ball.Position)
                    
                    if onScreen then
                        local yOffset = -60
                        
                        if ESPSettings.ShowDistance then
                            local distColor = ESPSettings.DistanceColor
                            local distanceText = distance .. " studs | " .. speed .. " speed"
                            
                            local now = tick()
                            local recentParries = 0
                            for _, parry in ipairs(_G.AutoParryState.ParryHistory) do
                                if now - parry.time <= Config.ClashActivationTime then
                                    recentParries = recentParries + 1
                                end
                            end
                            
                            if _G.AutoParryState.ClashMode and Config.AutoClashEnabled then
                                local timeSinceLastParry = now - _G.AutoParryState.LastClashParryTime
                                local timeLeft = Config.ClashDeactivationTime - timeSinceLastParry
                                distColor = Color3.fromRGB(255, 0, 255)
                                distanceText = string.format("âš¡ CLASH ACTIVE [%.1fs]", math.max(0, timeLeft))
                            elseif recentParries > 0 then
                                distColor = Color3.fromRGB(255, 165, 0)
                                distanceText = string.format("%d studs | %d/%d parries", distance, recentParries, Config.ClashMinParries)
                            elseif distance <= 30 then
                                distColor = Color3.fromRGB(255, 50, 50)
                            elseif distance <= 45 then
                                distColor = Color3.fromRGB(255, 165, 0)
                            elseif distance <= 70 then
                                distColor = Color3.fromRGB(255, 255, 0)
                            else
                                distColor = Color3.fromRGB(0, 255, 255)
                            end
                            
                            DrawingImmediate.OutlinedText(
                                vector.create(screenPos.X, screenPos.Y + yOffset),
                                14,
                                distColor,
                                1,
                                distanceText,
                                true,
                                nil
                            )
                            yOffset = yOffset + 20
                        end
                        
                        if CurveState.lastDisplayLevel ~= "None" then
                            local color = CurveColors[CurveState.lastDisplayLevel]
                            local text = "CURVE: " .. CurveState.lastDisplayLevel
                            
                            DrawingImmediate.OutlinedText(
                                vector.create(screenPos.X, screenPos.Y + yOffset),
                                16,
                                color,
                                1,
                                text,
                                true,
                                nil
                            )
                            
                            local barWidth = 100
                            local barHeight = 6
                            local fillWidth = barWidth * math.min(1, CurveState.lastDisplayIntensity / 0.6)
                            
                            DrawingImmediate.FilledRect(
                                vector.create(screenPos.X - barWidth/2, screenPos.Y + yOffset + 15),
                                vector.create(barWidth, barHeight),
                                Color3.fromRGB(50, 50, 50),
                                0.7
                            )
                            
                            DrawingImmediate.FilledRect(
                                vector.create(screenPos.X - barWidth/2, screenPos.Y + yOffset + 15),
                                vector.create(fillWidth, barHeight),
                                color,
                                1
                            )
                        else
                            DrawingImmediate.OutlinedText(
                                vector.create(screenPos.X, screenPos.Y + yOffset),
                                16,
                                Color3.fromRGB(255, 255, 255),
                                0.7,
                                "STRAIGHT",
                                true,
                                nil
                            )
                        end
                    end
                end
            end
        end
        
        if not ESPSettings.Enabled then return end
        
        local localName = _G.AutoParryState.LocalPlayer.Name
        local aliveFolder = workspace:FindFirstChild("Alive")
        if not aliveFolder then return end
        
        local characters = aliveFolder:GetChildren()
        local alivePlayerNames = {}
        
        for _, character in characters do
            alivePlayerNames[character.Name] = true
        end
        
        for cachedName, _ in pairs(_ESPAbilityCache) do
            if not alivePlayerNames[cachedName] then
                _ESPAbilityCache[cachedName] = nil
            end
        end
        
        for _, character in characters do
            local playerName = character.Name
            
            if playerName ~= localName then
                local head = character:FindFirstChild("Head")
                if head then
                    local headPos = head.Position + Vector3.new(0, 2, 0)
                    local screenPos, onScreen = camera:WorldToScreenPoint(headPos)
                    
                    if onScreen then
                        local abilityText = nil
                        
                        local player = Players:FindFirstChild(playerName)
                        if player then
                            local equippedAbility = player:GetAttribute("EquippedAbility")
                            if equippedAbility and tostring(equippedAbility) ~= "" then
                                abilityText = tostring(equippedAbility)
                            end
                        end
                        
                        if not abilityText then
                            local charAbility = character:GetAttribute("EquippedAbility")
                            if charAbility and tostring(charAbility) ~= "" then
                                abilityText = tostring(charAbility)
                            end
                        end
                        
                        if not abilityText then
                            local hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local hrpAbility = hrp:GetAttribute("EquippedAbility")
                                if hrpAbility and tostring(hrpAbility) ~= "" then
                                    abilityText = tostring(hrpAbility)
                                end
                            end
                        end
                        
                        if abilityText and abilityText ~= "" then
                            _ESPAbilityCache[playerName] = abilityText
                        else
                            abilityText = _ESPAbilityCache[playerName]
                        end
                        
                        if abilityText and abilityText ~= "" then
                            DrawingImmediate.OutlinedText(
                                vector.create(screenPos.X, screenPos.Y - 20),
                                ESPSettings.TextSize,
                                ESPSettings.AbilityColor,
                                ESPSettings.Opacity,
                                abilityText,
                                true,
                                nil
                            )
                        end
                        
                        if ESPSettings.ShowDistance and playerPos then
                            local hrp = character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local distance = math.floor(VectorMagnitude(hrp.Position - playerPos))
                                local distText = distance .. " studs"
                                
                                DrawingImmediate.OutlinedText(
                                    vector.create(screenPos.X, screenPos.Y - 5),
                                    12,
                                    ESPSettings.DistanceColor,
                                    0.8,
                                    distText,
                                    true,
                                    nil
                                )
                            end
                        end
                    end
                end
            end
        end
    end)
end)

Window:Notify("Who's AP?", 3)
